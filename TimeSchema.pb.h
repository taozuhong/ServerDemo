// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TimeSchema.proto

#ifndef PROTOBUF_TimeSchema_2eproto__INCLUDED
#define PROTOBUF_TimeSchema_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TimeSchema_2eproto();
void protobuf_AssignDesc_TimeSchema_2eproto();
void protobuf_ShutdownFile_TimeSchema_2eproto();

class TimeStamp;
class HeartMsg;
class BroadMsg;
class PkgHead;
class PkgBody;
class CltSvrPkg;

enum CmdActions {
  CMD_UNKNOWN = 0,
  CMD_TIME = 1,
  CMD_HEART = 2,
  CMD_BROAD = 3
};
bool CmdActions_IsValid(int value);
const CmdActions CmdActions_MIN = CMD_UNKNOWN;
const CmdActions CmdActions_MAX = CMD_BROAD;
const int CmdActions_ARRAYSIZE = CmdActions_MAX + 1;

const ::google::protobuf::EnumDescriptor* CmdActions_descriptor();
inline const ::std::string& CmdActions_Name(CmdActions value) {
  return ::google::protobuf::internal::NameOfEnum(
    CmdActions_descriptor(), value);
}
inline bool CmdActions_Parse(
    const ::std::string& name, CmdActions* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CmdActions>(
    CmdActions_descriptor(), name, value);
}
// ===================================================================

class TimeStamp : public ::google::protobuf::Message {
 public:
  TimeStamp();
  virtual ~TimeStamp();

  TimeStamp(const TimeStamp& from);

  inline TimeStamp& operator=(const TimeStamp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeStamp& default_instance();

  void Swap(TimeStamp* other);

  // implements Message ----------------------------------------------

  TimeStamp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeStamp& from);
  void MergeFrom(const TimeStamp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // required uint64 Tick = 2;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 2;
  inline ::google::protobuf::uint64 tick() const;
  inline void set_tick(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:TimeStamp)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_tick();
  inline void clear_has_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* time_;
  ::google::protobuf::uint64 tick_;
  friend void  protobuf_AddDesc_TimeSchema_2eproto();
  friend void protobuf_AssignDesc_TimeSchema_2eproto();
  friend void protobuf_ShutdownFile_TimeSchema_2eproto();

  void InitAsDefaultInstance();
  static TimeStamp* default_instance_;
};
// -------------------------------------------------------------------

class HeartMsg : public ::google::protobuf::Message {
 public:
  HeartMsg();
  virtual ~HeartMsg();

  HeartMsg(const HeartMsg& from);

  inline HeartMsg& operator=(const HeartMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartMsg& default_instance();

  void Swap(HeartMsg* other);

  // implements Message ----------------------------------------------

  HeartMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartMsg& from);
  void MergeFrom(const HeartMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Tick = 1;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 1;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // required uint64 UID = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUIDFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:HeartMsg)
 private:
  inline void set_has_tick();
  inline void clear_has_tick();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 tick_;
  friend void  protobuf_AddDesc_TimeSchema_2eproto();
  friend void protobuf_AssignDesc_TimeSchema_2eproto();
  friend void protobuf_ShutdownFile_TimeSchema_2eproto();

  void InitAsDefaultInstance();
  static HeartMsg* default_instance_;
};
// -------------------------------------------------------------------

class BroadMsg : public ::google::protobuf::Message {
 public:
  BroadMsg();
  virtual ~BroadMsg();

  BroadMsg(const BroadMsg& from);

  inline BroadMsg& operator=(const BroadMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadMsg& default_instance();

  void Swap(BroadMsg* other);

  // implements Message ----------------------------------------------

  BroadMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BroadMsg& from);
  void MergeFrom(const BroadMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // required string Message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional uint64 TimeStamp = 3 [default = 0];
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 3;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:BroadMsg)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::std::string* message_;
  ::google::protobuf::uint64 timestamp_;
  friend void  protobuf_AddDesc_TimeSchema_2eproto();
  friend void protobuf_AssignDesc_TimeSchema_2eproto();
  friend void protobuf_ShutdownFile_TimeSchema_2eproto();

  void InitAsDefaultInstance();
  static BroadMsg* default_instance_;
};
// -------------------------------------------------------------------

class PkgHead : public ::google::protobuf::Message {
 public:
  PkgHead();
  virtual ~PkgHead();

  PkgHead(const PkgHead& from);

  inline PkgHead& operator=(const PkgHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PkgHead& default_instance();

  void Swap(PkgHead* other);

  // implements Message ----------------------------------------------

  PkgHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PkgHead& from);
  void MergeFrom(const PkgHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CmdActions Cmd = 1 [default = CMD_HEART];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::CmdActions cmd() const;
  inline void set_cmd(::CmdActions value);

  // required uint32 CmdType = 2;
  inline bool has_cmdtype() const;
  inline void clear_cmdtype();
  static const int kCmdTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 cmdtype() const;
  inline void set_cmdtype(::google::protobuf::uint32 value);

  // required uint32 CmdSeq = 3;
  inline bool has_cmdseq() const;
  inline void clear_cmdseq();
  static const int kCmdSeqFieldNumber = 3;
  inline ::google::protobuf::uint32 cmdseq() const;
  inline void set_cmdseq(::google::protobuf::uint32 value);

  // required uint32 SrcID = 4;
  inline bool has_srcid() const;
  inline void clear_srcid();
  static const int kSrcIDFieldNumber = 4;
  inline ::google::protobuf::uint32 srcid() const;
  inline void set_srcid(::google::protobuf::uint32 value);

  // required uint32 DstID = 5;
  inline bool has_dstid() const;
  inline void clear_dstid();
  static const int kDstIDFieldNumber = 5;
  inline ::google::protobuf::uint32 dstid() const;
  inline void set_dstid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PkgHead)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_cmdtype();
  inline void clear_has_cmdtype();
  inline void set_has_cmdseq();
  inline void clear_has_cmdseq();
  inline void set_has_srcid();
  inline void clear_has_srcid();
  inline void set_has_dstid();
  inline void clear_has_dstid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int cmd_;
  ::google::protobuf::uint32 cmdtype_;
  ::google::protobuf::uint32 cmdseq_;
  ::google::protobuf::uint32 srcid_;
  ::google::protobuf::uint32 dstid_;
  friend void  protobuf_AddDesc_TimeSchema_2eproto();
  friend void protobuf_AssignDesc_TimeSchema_2eproto();
  friend void protobuf_ShutdownFile_TimeSchema_2eproto();

  void InitAsDefaultInstance();
  static PkgHead* default_instance_;
};
// -------------------------------------------------------------------

class PkgBody : public ::google::protobuf::Message {
 public:
  PkgBody();
  virtual ~PkgBody();

  PkgBody(const PkgBody& from);

  inline PkgBody& operator=(const PkgBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PkgBody& default_instance();

  enum BodyCase {
    kTime = 1,
    kHeart = 2,
    kInfo = 3,
    BODY_NOT_SET = 0,
  };

  void Swap(PkgBody* other);

  // implements Message ----------------------------------------------

  PkgBody* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PkgBody& from);
  void MergeFrom(const PkgBody& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TimeStamp Time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline const ::TimeStamp& time() const;
  inline ::TimeStamp* mutable_time();
  inline ::TimeStamp* release_time();
  inline void set_allocated_time(::TimeStamp* time);

  // optional .HeartMsg Heart = 2;
  inline bool has_heart() const;
  inline void clear_heart();
  static const int kHeartFieldNumber = 2;
  inline const ::HeartMsg& heart() const;
  inline ::HeartMsg* mutable_heart();
  inline ::HeartMsg* release_heart();
  inline void set_allocated_heart(::HeartMsg* heart);

  // optional .BroadMsg Info = 3;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 3;
  inline const ::BroadMsg& info() const;
  inline ::BroadMsg* mutable_info();
  inline ::BroadMsg* release_info();
  inline void set_allocated_info(::BroadMsg* info);

  inline BodyCase Body_case() const;
  // @@protoc_insertion_point(class_scope:PkgBody)
 private:
  inline void set_has_time();
  inline void set_has_heart();
  inline void set_has_info();

  inline bool has_Body();
  void clear_Body();
  inline void clear_has_Body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union BodyUnion {
    ::TimeStamp* time_;
    ::HeartMsg* heart_;
    ::BroadMsg* info_;
  } Body_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_TimeSchema_2eproto();
  friend void protobuf_AssignDesc_TimeSchema_2eproto();
  friend void protobuf_ShutdownFile_TimeSchema_2eproto();

  void InitAsDefaultInstance();
  static PkgBody* default_instance_;
};
// -------------------------------------------------------------------

class CltSvrPkg : public ::google::protobuf::Message {
 public:
  CltSvrPkg();
  virtual ~CltSvrPkg();

  CltSvrPkg(const CltSvrPkg& from);

  inline CltSvrPkg& operator=(const CltSvrPkg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CltSvrPkg& default_instance();

  void Swap(CltSvrPkg* other);

  // implements Message ----------------------------------------------

  CltSvrPkg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CltSvrPkg& from);
  void MergeFrom(const CltSvrPkg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PkgHead Head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::PkgHead& head() const;
  inline ::PkgHead* mutable_head();
  inline ::PkgHead* release_head();
  inline void set_allocated_head(::PkgHead* head);

  // required .PkgBody Data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::PkgBody& data() const;
  inline ::PkgBody* mutable_data();
  inline ::PkgBody* release_data();
  inline void set_allocated_data(::PkgBody* data);

  // @@protoc_insertion_point(class_scope:CltSvrPkg)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::PkgHead* head_;
  ::PkgBody* data_;
  friend void  protobuf_AddDesc_TimeSchema_2eproto();
  friend void protobuf_AssignDesc_TimeSchema_2eproto();
  friend void protobuf_ShutdownFile_TimeSchema_2eproto();

  void InitAsDefaultInstance();
  static CltSvrPkg* default_instance_;
};
// ===================================================================


// ===================================================================

// TimeStamp

// required string Time = 1;
inline bool TimeStamp::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeStamp::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeStamp::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeStamp::clear_time() {
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& TimeStamp::time() const {
  // @@protoc_insertion_point(field_get:TimeStamp.Time)
  return *time_;
}
inline void TimeStamp::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(value);
  // @@protoc_insertion_point(field_set:TimeStamp.Time)
}
inline void TimeStamp::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(value);
  // @@protoc_insertion_point(field_set_char:TimeStamp.Time)
}
inline void TimeStamp::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TimeStamp.Time)
}
inline ::std::string* TimeStamp::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TimeStamp.Time)
  return time_;
}
inline ::std::string* TimeStamp::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TimeStamp::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TimeStamp.Time)
}

// required uint64 Tick = 2;
inline bool TimeStamp::has_tick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeStamp::set_has_tick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeStamp::clear_has_tick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeStamp::clear_tick() {
  tick_ = GOOGLE_ULONGLONG(0);
  clear_has_tick();
}
inline ::google::protobuf::uint64 TimeStamp::tick() const {
  // @@protoc_insertion_point(field_get:TimeStamp.Tick)
  return tick_;
}
inline void TimeStamp::set_tick(::google::protobuf::uint64 value) {
  set_has_tick();
  tick_ = value;
  // @@protoc_insertion_point(field_set:TimeStamp.Tick)
}

// -------------------------------------------------------------------

// HeartMsg

// required uint32 Tick = 1;
inline bool HeartMsg::has_tick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartMsg::set_has_tick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartMsg::clear_has_tick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartMsg::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 HeartMsg::tick() const {
  // @@protoc_insertion_point(field_get:HeartMsg.Tick)
  return tick_;
}
inline void HeartMsg::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
  // @@protoc_insertion_point(field_set:HeartMsg.Tick)
}

// required uint64 UID = 2;
inline bool HeartMsg::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartMsg::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartMsg::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartMsg::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 HeartMsg::uid() const {
  // @@protoc_insertion_point(field_get:HeartMsg.UID)
  return uid_;
}
inline void HeartMsg::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:HeartMsg.UID)
}

// -------------------------------------------------------------------

// BroadMsg

// required string Title = 1;
inline bool BroadMsg::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadMsg::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadMsg::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadMsg::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& BroadMsg::title() const {
  // @@protoc_insertion_point(field_get:BroadMsg.Title)
  return *title_;
}
inline void BroadMsg::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:BroadMsg.Title)
}
inline void BroadMsg::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:BroadMsg.Title)
}
inline void BroadMsg::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BroadMsg.Title)
}
inline ::std::string* BroadMsg::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BroadMsg.Title)
  return title_;
}
inline ::std::string* BroadMsg::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BroadMsg::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BroadMsg.Title)
}

// required string Message = 2;
inline bool BroadMsg::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BroadMsg::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BroadMsg::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BroadMsg::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& BroadMsg::message() const {
  // @@protoc_insertion_point(field_get:BroadMsg.Message)
  return *message_;
}
inline void BroadMsg::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:BroadMsg.Message)
}
inline void BroadMsg::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:BroadMsg.Message)
}
inline void BroadMsg::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BroadMsg.Message)
}
inline ::std::string* BroadMsg::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BroadMsg.Message)
  return message_;
}
inline ::std::string* BroadMsg::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BroadMsg::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BroadMsg.Message)
}

// optional uint64 TimeStamp = 3 [default = 0];
inline bool BroadMsg::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BroadMsg::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BroadMsg::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BroadMsg::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 BroadMsg::timestamp() const {
  // @@protoc_insertion_point(field_get:BroadMsg.TimeStamp)
  return timestamp_;
}
inline void BroadMsg::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:BroadMsg.TimeStamp)
}

// -------------------------------------------------------------------

// PkgHead

// required .CmdActions Cmd = 1 [default = CMD_HEART];
inline bool PkgHead::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PkgHead::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PkgHead::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PkgHead::clear_cmd() {
  cmd_ = 2;
  clear_has_cmd();
}
inline ::CmdActions PkgHead::cmd() const {
  // @@protoc_insertion_point(field_get:PkgHead.Cmd)
  return static_cast< ::CmdActions >(cmd_);
}
inline void PkgHead::set_cmd(::CmdActions value) {
  assert(::CmdActions_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:PkgHead.Cmd)
}

// required uint32 CmdType = 2;
inline bool PkgHead::has_cmdtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PkgHead::set_has_cmdtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PkgHead::clear_has_cmdtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PkgHead::clear_cmdtype() {
  cmdtype_ = 0u;
  clear_has_cmdtype();
}
inline ::google::protobuf::uint32 PkgHead::cmdtype() const {
  // @@protoc_insertion_point(field_get:PkgHead.CmdType)
  return cmdtype_;
}
inline void PkgHead::set_cmdtype(::google::protobuf::uint32 value) {
  set_has_cmdtype();
  cmdtype_ = value;
  // @@protoc_insertion_point(field_set:PkgHead.CmdType)
}

// required uint32 CmdSeq = 3;
inline bool PkgHead::has_cmdseq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PkgHead::set_has_cmdseq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PkgHead::clear_has_cmdseq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PkgHead::clear_cmdseq() {
  cmdseq_ = 0u;
  clear_has_cmdseq();
}
inline ::google::protobuf::uint32 PkgHead::cmdseq() const {
  // @@protoc_insertion_point(field_get:PkgHead.CmdSeq)
  return cmdseq_;
}
inline void PkgHead::set_cmdseq(::google::protobuf::uint32 value) {
  set_has_cmdseq();
  cmdseq_ = value;
  // @@protoc_insertion_point(field_set:PkgHead.CmdSeq)
}

// required uint32 SrcID = 4;
inline bool PkgHead::has_srcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PkgHead::set_has_srcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PkgHead::clear_has_srcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PkgHead::clear_srcid() {
  srcid_ = 0u;
  clear_has_srcid();
}
inline ::google::protobuf::uint32 PkgHead::srcid() const {
  // @@protoc_insertion_point(field_get:PkgHead.SrcID)
  return srcid_;
}
inline void PkgHead::set_srcid(::google::protobuf::uint32 value) {
  set_has_srcid();
  srcid_ = value;
  // @@protoc_insertion_point(field_set:PkgHead.SrcID)
}

// required uint32 DstID = 5;
inline bool PkgHead::has_dstid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PkgHead::set_has_dstid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PkgHead::clear_has_dstid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PkgHead::clear_dstid() {
  dstid_ = 0u;
  clear_has_dstid();
}
inline ::google::protobuf::uint32 PkgHead::dstid() const {
  // @@protoc_insertion_point(field_get:PkgHead.DstID)
  return dstid_;
}
inline void PkgHead::set_dstid(::google::protobuf::uint32 value) {
  set_has_dstid();
  dstid_ = value;
  // @@protoc_insertion_point(field_set:PkgHead.DstID)
}

// -------------------------------------------------------------------

// PkgBody

// optional .TimeStamp Time = 1;
inline bool PkgBody::has_time() const {
  return Body_case() == kTime;
}
inline void PkgBody::set_has_time() {
  _oneof_case_[0] = kTime;
}
inline void PkgBody::clear_time() {
  if (has_time()) {
    delete Body_.time_;
    clear_has_Body();
  }
}
inline const ::TimeStamp& PkgBody::time() const {
  return has_time() ? *Body_.time_
                      : ::TimeStamp::default_instance();
}
inline ::TimeStamp* PkgBody::mutable_time() {
  if (!has_time()) {
    clear_Body();
    set_has_time();
    Body_.time_ = new ::TimeStamp;
  }
  return Body_.time_;
}
inline ::TimeStamp* PkgBody::release_time() {
  if (has_time()) {
    clear_has_Body();
    ::TimeStamp* temp = Body_.time_;
    Body_.time_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PkgBody::set_allocated_time(::TimeStamp* time) {
  clear_Body();
  if (time) {
    set_has_time();
    Body_.time_ = time;
  }
}

// optional .HeartMsg Heart = 2;
inline bool PkgBody::has_heart() const {
  return Body_case() == kHeart;
}
inline void PkgBody::set_has_heart() {
  _oneof_case_[0] = kHeart;
}
inline void PkgBody::clear_heart() {
  if (has_heart()) {
    delete Body_.heart_;
    clear_has_Body();
  }
}
inline const ::HeartMsg& PkgBody::heart() const {
  return has_heart() ? *Body_.heart_
                      : ::HeartMsg::default_instance();
}
inline ::HeartMsg* PkgBody::mutable_heart() {
  if (!has_heart()) {
    clear_Body();
    set_has_heart();
    Body_.heart_ = new ::HeartMsg;
  }
  return Body_.heart_;
}
inline ::HeartMsg* PkgBody::release_heart() {
  if (has_heart()) {
    clear_has_Body();
    ::HeartMsg* temp = Body_.heart_;
    Body_.heart_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PkgBody::set_allocated_heart(::HeartMsg* heart) {
  clear_Body();
  if (heart) {
    set_has_heart();
    Body_.heart_ = heart;
  }
}

// optional .BroadMsg Info = 3;
inline bool PkgBody::has_info() const {
  return Body_case() == kInfo;
}
inline void PkgBody::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void PkgBody::clear_info() {
  if (has_info()) {
    delete Body_.info_;
    clear_has_Body();
  }
}
inline const ::BroadMsg& PkgBody::info() const {
  return has_info() ? *Body_.info_
                      : ::BroadMsg::default_instance();
}
inline ::BroadMsg* PkgBody::mutable_info() {
  if (!has_info()) {
    clear_Body();
    set_has_info();
    Body_.info_ = new ::BroadMsg;
  }
  return Body_.info_;
}
inline ::BroadMsg* PkgBody::release_info() {
  if (has_info()) {
    clear_has_Body();
    ::BroadMsg* temp = Body_.info_;
    Body_.info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PkgBody::set_allocated_info(::BroadMsg* info) {
  clear_Body();
  if (info) {
    set_has_info();
    Body_.info_ = info;
  }
}

inline bool PkgBody::has_Body() {
  return Body_case() != BODY_NOT_SET;
}
inline void PkgBody::clear_has_Body() {
  _oneof_case_[0] = BODY_NOT_SET;
}
inline PkgBody::BodyCase PkgBody::Body_case() const {
  return PkgBody::BodyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CltSvrPkg

// required .PkgHead Head = 1;
inline bool CltSvrPkg::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltSvrPkg::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltSvrPkg::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltSvrPkg::clear_head() {
  if (head_ != NULL) head_->::PkgHead::Clear();
  clear_has_head();
}
inline const ::PkgHead& CltSvrPkg::head() const {
  // @@protoc_insertion_point(field_get:CltSvrPkg.Head)
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::PkgHead* CltSvrPkg::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::PkgHead;
  // @@protoc_insertion_point(field_mutable:CltSvrPkg.Head)
  return head_;
}
inline ::PkgHead* CltSvrPkg::release_head() {
  clear_has_head();
  ::PkgHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void CltSvrPkg::set_allocated_head(::PkgHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:CltSvrPkg.Head)
}

// required .PkgBody Data = 2;
inline bool CltSvrPkg::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltSvrPkg::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltSvrPkg::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltSvrPkg::clear_data() {
  if (data_ != NULL) data_->::PkgBody::Clear();
  clear_has_data();
}
inline const ::PkgBody& CltSvrPkg::data() const {
  // @@protoc_insertion_point(field_get:CltSvrPkg.Data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::PkgBody* CltSvrPkg::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::PkgBody;
  // @@protoc_insertion_point(field_mutable:CltSvrPkg.Data)
  return data_;
}
inline ::PkgBody* CltSvrPkg::release_data() {
  clear_has_data();
  ::PkgBody* temp = data_;
  data_ = NULL;
  return temp;
}
inline void CltSvrPkg::set_allocated_data(::PkgBody* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:CltSvrPkg.Data)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::CmdActions> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CmdActions>() {
  return ::CmdActions_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TimeSchema_2eproto__INCLUDED
